Getting started
- Prerequisites (Update angular-cli, npm i -g @angular/cli)
- Installation
- Create a workspace (ng new <APP-NAME>)
- Serve the application (ng serve -o)

Architecture overview
- Folders information (dist, e2e, src, node_module)
- Files information (.editorconfig, .gitignore, angular.json, package.json, package-lock.json, tsconfig.json, tslint.json)

Angular overview (MVVM)
- Check Image

Application overview
- Modules (Metadata, bootstraping, shared module, library adding)
- Components (Metadata)
- Data binding (Directives types)
- Services (Metadata, from root)
- Dependency injection (Creation, Definition, Declaration, Injection)
- Routing (Routing module)

Displaying Data
- String interpolation
- Variable initialization
- Creating Modal

Template Syntax (In Angular, the component plays the part of the controller/viewmodel, and the template represents the view.)
- Invalid HTML syntax  <script>, <html>, <body>, and <base>
- Template expressions
	<img src="{{heroImageUrl}}" style="height:30px">
	<p>The sum of 1 + 1 is {{1 + 1}}</p>
	<p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}</p>
	+, - , *, /, ?:
	
One-way (component's data property into a target element property)
- Property binding ( [property] )	
- Event binding ( (event) )
	$event (it is a DOM event object, with properties such as target and target.value.)
- Binding targets
	Property <img [src]="heroImageUrl">
	Event <button (click)="onSave()">Save</button>
	Two-way <input [(ngModel)]="name">
	Attribute <button [attr.aria-label]="help">help</button>
	Class <div [class.special]="isSpecial">Special</div>
	Style <button [style.color]="isSpecial ? 'red' : 'green'">


Two-way binding ( [(...)] ) BANANA IN A BOX

Built-in attribute directives
- [ngClass] - add and remove a set of CSS classes, <div [ngClass]="{'currentClasses':expression}"></div>
- [ngStyle] - add and remove a set of HTML styles
- [(ngModel)] - two-way data binding to an HTML form element

Built-in structural directives
- *ngIf - Guard against null, conditionally add or remove an element from the DOM <app-hero-detail *ngIf="isActive"></app-hero-detail>
- *ngSwitch - a set of directives that switch among alternative views
	<div [ngSwitch]="currentHero.emotion">
	  <app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"></app-confused-hero>
	  <app-unknown-hero  *ngSwitchDefault           [hero]="currentHero"></app-unknown-hero>
	</div>
- *ngFor - repeat a template for each item in a list <div *ngFor="let hero of heroes">{{hero.name}}</div>
	*ngFor with index <div *ngFor="let hero of heroes; let i=index">{{i + 1}} - {{hero.name}}</div>
	*ngFor with trackBy <div *ngFor="let hero of heroes; trackBy: trackByHeroes">

Template reference variables ( #var )
	<input #phone placeholder="phone number">
	<button (click)="callPhone(phone.value)">Call</button>

Input and Output properties (Custom Property & Custom Event binding), You can only bind to another component or directive through its Input and Output properties.
- Declaring Input and Output properties
	<app-hero-detail [hero]="currentHero" (deleteRequest)="deleteHero($event)"></app-hero-detail>
	@Input()  hero: Hero;
	@Output() deleteRequest = new EventEmitter<Hero>();
	this.deleteRequest.emit(Hero);
- Aliasing input/output properties

Template expression operators
- The pipe operator ( | ), {{title | uppercase}}, Pipe chain  {{title | uppercase | lowercase}}
- The safe navigation operator ( ?. ) and null property paths {{currentHero?.name}}
- The non-null assertion operator ( ! ) it tells the TypeScript type checker to suspend strict null checks for a specific property expression
- The $any type cast function ($any( <expression> )) Accessing an undeclared member {{$any(this).member}}

User Input
	Binding to user input events
	Get user input from the $event object
		onKey(event: any) { // without type info
			this.values += event.target.value + ' | ';
		}
	Type the $event
		this.values += (<HTMLInputElement>event.target).value + ' | ';
	Get user input from a template reference variable
	Key event filtering 
		<input #box (keyup.enter)="onEnter(box.value)">
	Observations
		Use template variables to refer to elements
		Pass values, not elements
		Keep template statements simple
		
Lifecycle Hooks
	Component lifecycle hooks overview (Directive and component instances have a lifecycle as Angular creates, updates, and destroys them)
	Lifecycle sequence
		ngOnChanges() - The method receives a SimpleChanges object of current and previous property values,Called before ngOnInit() and whenever one or more data-bound input properties change.
		ngOnInit()
		ngDoCheck() - Detect and act upon changes that Angular can't or won't detect on its own.Called during every change detection run
		ngAfterContentInit() - Respond after Angular projects external content into the component's view
		ngAfterContentChecked() - Respond after Angular checks the content projected into the directive/component.
		ngAfterViewInit() - Respond after Angular initializes the component's views and child views / the view that a directive is in.
		ngAfterViewChecked() - Respond after Angular checks the component's views and child views / the view that a directive is in
		ngOnDestroy() - Cleanup just before Angular destroys the directive/component
		
Component Interaction
	Pass data from parent to child with input binding
	Intercept input property changes with a setter
		@Input()
		set name(name: string) {
			this._name = (name && name.trim()) || '<no name set>';
		}
		 
		get name(): string { return this._name; }
	Intercept input property changes with ngOnChanges()
	Parent listens for child event
		The child component exposes an EventEmitter property with which it emits events when something happens. The parent binds to that event property and reacts to those events.
	Parent interacts with child via local variable
		<app-countdown-timer #timer></app-countdown-timer>
	Parent calls an @ViewChild()
		@ViewChild(CountdownTimerComponent)
		private timerComponent: CountdownTimerComponent;
	Parent and children communicate via a service
		private missionAnnouncedSource = new Subject<string>();
		 
		// Observable string streams
		missionAnnounced$ = this.missionAnnouncedSource.asObservable();
		 
		// Service message commands
		announceMission(mission: string) {
			this.missionAnnouncedSource.next(mission);
		}
		
Component Styles
	Style scope
	Special selectors
		:host - Use the :host pseudo-class selector to target styles in the element that hosts the component
		
		:host(.active) {
		  border-width: 3px;
		}
		:host-context() - The :host-context() selector looks for a CSS class in any ancestor of the component host element, up to the document root
		
		:host-context(.theme-light) h2 {
		  background-color: #eef;
		}
		
	Loading component styles
		By setting styles or styleUrls metadata.
		Inline in the template HTML.
		With CSS imports
	External and global style files - angular.json / style.css
	Non-CSS style files - .scss, .less, .styl
	View encapsulation - As discussed earlier, component CSS styles are encapsulated into the component's view and don't affect the rest of the application.
		encapsulation: ViewEncapsulation.ShadowDom/Emulated(default)/Native/None
	Inspecting generated CSS - add  _ngcontent with Emulated
	
Angular Elements Overview
	Using custom elements - Custom elements bootstrap themselves - they start automatically when they are added to the DOM, and are automatically destroyed when removed from the DOM. Once a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular terms or usage conventions
	
Dynamic Component Loader
	Example of left-right component
	Component templates are not always fixed. An application may need to load new components at runtime
	
Attribute Directives
	An Attribute directive changes the appearance or behavior of a DOM element.
	Directives overview
		Components—directives with a template.
		Structural directives—change the DOM layout by adding and removing DOM elements.
		Attribute directives—change the appearance or behavior of an element, component, or another directive.
	Build a simple attribute directive
		constructor(el: ElementRef) {
		   el.nativeElement.style.backgroundColor = 'yellow';
		}
	Apply the attribute directive - <p appHighlight>Highlight me!</p>
	Respond to user-initiated events
		@HostListener('mouseenter') onMouseEnter() {
		  this.highlight('yellow');
		}
		private highlight(color: string) {
		  this.el.nativeElement.style.backgroundColor = color;
		}
	Pass values into the directive with an @Input data binding
		@Input() highlightColor: string;
		<p appHighlight [highlightColor]="'orange'">Highlighted in orange</p>
		For same directive
		<p [appHighlight]="color">Highlight me!</p>
		@Input() appHighlight: string;
	Bind to an @Input alias
		@Input('appHighlight') highlightColor: string;
		<p [appHighlight]="color">Highlight me!</p>
Structural Directives
	Structural directives are responsible for HTML layout. They shape or reshape the DOM's structure, typically by adding, removing, or manipulating elements.
	The <ng-template> - The <ng-template> is an Angular element for rendering HTML. It is never displayed directly. In fact, before rendering the view, Angular replaces the <ng-template> and its contents with a comment.
	<ng-container> - The Angular <ng-container> is a grouping element that doesn't interfere with styles or layout because Angular doesn't put it in the DOM.
	Not possible to write 2 Structural directives on same element thats why use <ng-container>
	Write a structural directive
	
	
